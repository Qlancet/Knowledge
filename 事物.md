# 

### 共享锁和排它锁

​	共享锁(lock in share mode): select * from test where id=1 lock in share mode;

​	**允许其他事务增加共享锁读取，不允许其他事务增加排他锁，当事务同时增加共享锁时候，事务的更新必须等  待先执行的事务commit后才行，如果同时并发太大可能很容易造成死锁**

​	排它锁(for update)：select * from test where id = 1 for update;

**只有当前的事务可以读取数据，其他的事务不能读取也不能执行更新的操作，结果是超时或者等待第一个事务提交后再执行**

### mysql锁

![1615517015399](事物.assets/1615517015399.png)

### B树和B+树

![1615862562599](事物.assets/1615862562599.png)



**(1)**B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。我们可以认为在做单一数据查询的时候，使用B树平均性能更好。但是，由于B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作。

**(2)**B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。因此，在做单一数据的查询上，其平均性能并不如B树。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询。

因此，我们可以做一个推论:没准是Mysql中数据遍历操作比较多，所以用B+树作为索引结构。而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。

### SavePoint

```mysql
start transaction;
insert into auth_group(name) VALUES('caiji_06');
savepoint p1;
insert into auth_group(name) VALUES('caiji_07');
savepoint p2;
rollback to p1;
commit;
```
### B+计算

![1615876149274](事物.assets/1615876149274.png)

假设高度为2:一行数据大小为1k,计算

​	单个叶子节点条数: 16k/1k=16条

​	非叶子节点存放指针的个数: 假设主键为bigint:8字节, 指针6字节(InnoDB),一共是14i字节, 16k/14字节=1170

​	高度为2的: 16*1170=18720条

同理: 高度为3的: 1170*1170 * 16=21902400

### 聚集索引

​			https://blog.csdn.net/qq_37189082/article/details/99246581?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-13.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-13.control

​			聚集还是非聚集指的是B+Tree 叶结点存的是指针还是数据记录

​			MyISAM索引和数据分离，使用的是非聚集索引

​           InnoDB数据文件就是索引文件，主键索引就是聚集索引

![1615891821851](事物.assets/1615891821851.png)

### **非聚集索引**

​			![1615891805922](事物.assets/1615891805922.png)

![1615891949796](事物.assets/1615891949796.png)